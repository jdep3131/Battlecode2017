package examplefuncsplayer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import battlecode.common.*;

public strictfp class RobotPlayer {
	static RobotController rc;
	static int GARDENER_DISTRESS_CHANNEL = 2;
	static int GARDENER_PRODUCTION_CHANNEL = 1;
	static int GARDENER_NUM_CHANNEL = 10;
	static int ARCHON_DISTRESS_CHANNEL = 3;
	static int ARCHON_NUM_CHANNEL = 4;
	static int ARCHON_PRODUCTION_CHANNEL = 5;
	static int ARCHON_TOTAL_CHANNEL = 6;
	static int ARCHON_FUCK_CHANNEL = 7;
	static int GARDENER_SCHEDULE_CHANNEL = 8;
	static int GARDENER_AVAILABILITY_CHANNEL = 9;
	static int BIO_NUM_CHANNEL = 11;
	static int TARGET_X_COORD = 20;
	static int TARGET_Y_COORD = 21;
	static Team ourTeam;
	static Team opponentTeam;


	/**
	 * run() is the method that is called when a robot is instantiated in the Battlecode world.
	 * If this method returns, the robot dies!
	 **/
	@SuppressWarnings("unused")
	public static void run(RobotController rc) throws GameActionException {

		// This is the RobotController object. You use it to perform actions from this robot,
		// and to get information on its current status.
		RobotPlayer.rc = rc;
		ourTeam = rc.getTeam();
		opponentTeam = rc.getTeam().opponent();


		// Here, we've separated the controls into a different method for each RobotType.
		// You can add the missing ones or rewrite this into your own control structure.
		switch (rc.getType()) {
		case ARCHON:
			runArchon();
			break;
		case GARDENER:
			runGardener();
			break;
		case SOLDIER:
			runSoldier();
			break;
		case LUMBERJACK:
			runLumberjack();
			break;
		case SCOUT:
			runScout();
			break;
		case TANK:
			runTank();
			break;

		}
	}


	static void runArchon() throws GameActionException {
		MapLocation[] initialArchonLoc = rc.getInitialArchonLocations(rc.getTeam());
		int numberOfArchons = initialArchonLoc.length;
		rc.broadcast(ARCHON_TOTAL_CHANNEL, numberOfArchons);
		int archonNum = 0;
		boolean pinged = false;
		int numDecs = 0;
		for(int i = 0; i < numberOfArchons; i++) {
			if(rc.getLocation().equals(initialArchonLoc[i])) {
				archonNum = i;
			}
		}
		rc.broadcast(GARDENER_PRODUCTION_CHANNEL, -1 * numberOfArchons);
		// The code you want your robot to perform every round should be in this loop
		while (true) {
			// Try/catch blocks stop unhandled exceptions, which cause your robot to explode
			try {
				donateBullets();
				if (rc.isBuildReady()){
					/*if (rc.getTeamBullets()/500 > rc.readBroadcast(GARDENER_PRODUCTION_CHANNEL)+3){
					rc.broadcast(GARDENER_DISTRESS_CHANNEL, rc.readBroadcast(GARDENER_DISTRESS_CHANNEL)+1);
					}*/
					Direction checkDir = Direction.getNorth();
					boolean checker = false;
					for (int i = 10; i<360; i+=10){
						if (rc.canHireGardener(checkDir)){
							checker = true;
							break;
						}
						checkDir.rotateLeftDegrees(i);
					}
					if(!checker){
						rc.broadcast(ARCHON_FUCK_CHANNEL, 1);
					}
				}
				if (rc.readBroadcast(ARCHON_FUCK_CHANNEL) == 1){
					archonNum = cycleArchonNums(archonNum);
					if (archonNum == 2){
						rc.broadcast(ARCHON_FUCK_CHANNEL, 0);
					}
				}
				// every 300 rounds produce a gardener unless surrounded
				if (archonNum == 0 && rc.getRoundNum()<1100 &&rc.getRoundNum()%300 == 100){
					rc.broadcast(GARDENER_DISTRESS_CHANNEL, rc.readBroadcast(GARDENER_DISTRESS_CHANNEL) + 1);
				}
				if (archonNum == 0 && rc.getRoundNum() % 50 == 0) {
					if (rc.readBroadcast(GARDENER_NUM_CHANNEL) < rc.getTeamBullets()/75&& !checkSurrounded()){
						rc.broadcast(GARDENER_DISTRESS_CHANNEL, rc.readBroadcast(GARDENER_DISTRESS_CHANNEL) + 1);
					}
				}
				if (rc.getHealth()<10 && !pinged){
					rc.broadcast(ARCHON_DISTRESS_CHANNEL, rc.readBroadcast(ARCHON_DISTRESS_CHANNEL)+1);
					rc.broadcast(ARCHON_NUM_CHANNEL, archonNum);
					rc.broadcast(ARCHON_TOTAL_CHANNEL, rc.readBroadcast(ARCHON_TOTAL_CHANNEL)-1);
					pinged = true;
				}
				if (rc.readBroadcast(ARCHON_TOTAL_CHANNEL)-rc.readBroadcast(ARCHON_DISTRESS_CHANNEL)<rc.readBroadcast(ARCHON_TOTAL_CHANNEL)){
					if (archonNum>rc.readBroadcast(ARCHON_NUM_CHANNEL) && numDecs<rc.readBroadcast(ARCHON_DISTRESS_CHANNEL)){
						archonNum--;
						numDecs++;
					}

				}
				// Generate a random direction
				Direction dir = randomDirection();
				int distressSignals = rc.readBroadcast(GARDENER_DISTRESS_CHANNEL);
				int deadGardeners = rc.readBroadcast(GARDENER_PRODUCTION_CHANNEL);
				if (rc.canHireGardener(dir) && checkGardeners(deadGardeners, distressSignals)) {
					// figure out which archon will build gardener
					if(Math.abs(deadGardeners) % (rc.readBroadcast(ARCHON_TOTAL_CHANNEL)) == archonNum) {
						rc.hireGardener(dir);
						rc.broadcast(GARDENER_NUM_CHANNEL, rc.readBroadcast(GARDENER_NUM_CHANNEL)+1);
					}					
				}
				Direction randDir = randomDirection();
				if (rc.canMove(randDir)){
					tryMove(randDir);
				}
				// Clock.yield() makes the robot wait until the next turn, then it will perform this loop again
				Clock.yield();

			} catch (Exception e) {
				System.out.println("Archon Exception");
				e.printStackTrace();
			}
		}
	}

	static boolean checkSurrounded() {
		boolean surrounded = false;
		TreeInfo[] trees = rc.senseNearbyTrees(1);
		RobotInfo[] robots = rc.senseNearbyRobots(1);
		if(trees.length + robots.length > 4) {
			surrounded = true;
		}
		return surrounded;
	}

	private static int cycleArchonNums(int archonNum) throws GameActionException{
		switch (archonNum){
		case 0:
			return 2;
		case 1:
			return 0;
		case 2:
			return 1;
		}
		return -1;
	}

	static boolean checkGardeners(int deadGardeners, int distressSignals) throws GameActionException{
		if (distressSignals > deadGardeners){
			return true;
		}
		return false;
	}

	static void donateBullets() throws GameActionException {
		float cost = (float) (7.5 + rc.getRoundNum() * 12.5 / 3000);
		float bullets = rc.getTeamBullets();
		float surplus = bullets - 500 + rc.getRoundNum() / cost;
		if(surplus > 0) {
			rc.donate(surplus - (surplus % cost));
		}
		// if can win this turn, then win this turn
		if(rc.getTeamVictoryPoints() + (bullets / cost) >= 1000){
			rc.donate(bullets);
		}

		if(rc.getRoundLimit()-rc.getRoundNum() < 3){
			rc.donate(bullets);
		}
	}


		static void runGardener() throws GameActionException {
		boolean toProduce = false;
		boolean pinged = false;
		int buildCount = 0;

		rc.broadcast(GARDENER_PRODUCTION_CHANNEL, rc.readBroadcast(GARDENER_PRODUCTION_CHANNEL)+1);
		//int id = Math.abs(rc.readBroadcast(GARDENER_PRODUCTION_CHANNEL))%2;
		int id = 1;
		int spawnRound = rc.getRoundNum();
		int pauseProductionRound = rc.getRoundLimit();
		int productionCount = 0;
		RobotInfo[] initialRobots = rc.senseNearbyRobots(2, ourTeam);
		int numArchs = rc.getInitialArchonLocations(ourTeam).length;
		Direction oppDir = randomDirection();
		for(RobotInfo robot : initialRobots) {
			if(robot.type.equals(RobotType.ARCHON)) {
				oppDir = rc.getLocation().directionTo(robot.location).opposite();
			}
		}
		int bioMax = 50;
		if (numArchs == 1){
			bioMax = 50;
		}
		if (numArchs == 2){
			bioMax = 80;
		}
		if (numArchs == 3){
			bioMax = 100;
		}
		boolean hasBuiltLumb = false;
		while (true){
			// Try/catch blocks stop unhandled exceptions, which cause your robot to explode
			try {
				donateBullets();
				// Generate a random direction
				Direction dir = randomDirection();
				buildCount++;
				if(rc.getRoundNum() < spawnRound + 8 + (rc.readBroadcast(GARDENER_NUM_CHANNEL) * 2)) {
					tryMove(oppDir);
				} else if(!hasBuiltLumb){
					Direction LumbDir = findOpenDirection(RobotType.LUMBERJACK);
					if (rc.canBuildRobot(RobotType.LUMBERJACK, LumbDir)){
						rc.buildRobot(RobotType.LUMBERJACK, LumbDir);
						hasBuiltLumb = true;
					}
				}else{
					GardenersMove(id);
				}
				TreeInfo[] neutralTrees = rc.senseNearbyTrees(rc.getType().sensorRadius, Team.NEUTRAL);
				if (neutralTrees.length > 0) {
					shakeTrees(neutralTrees);
				}
				if (rc.getHealth()<10 && !pinged){
					rc.broadcast(GARDENER_DISTRESS_CHANNEL, rc.readBroadcast(GARDENER_DISTRESS_CHANNEL)+1);
					pinged = true;
					rc.broadcast(GARDENER_NUM_CHANNEL, rc.readBroadcast(GARDENER_NUM_CHANNEL)-1);
				}
				if (rc.readBroadcast(BIO_NUM_CHANNEL)>bioMax) {
					toProduce = false;
				} else {
					toProduce = true;
				}
				RobotType potentialRobot = null;
				int scheduleNum = rc.readBroadcast(GARDENER_SCHEDULE_CHANNEL) % 6;
				if (rc.getRoundNum()>400){
				if (scheduleNum == 0){
					potentialRobot = RobotType.SCOUT;
				}
				if (scheduleNum == 1){
					potentialRobot = RobotType.LUMBERJACK;
				}
				if (scheduleNum == 2){
					potentialRobot = RobotType.LUMBERJACK;
				}
				if (scheduleNum == 3){
					potentialRobot = RobotType.SOLDIER;
				}
				if (scheduleNum == 4){
					potentialRobot = RobotType.SOLDIER;
				}
				if (scheduleNum == 5){
					potentialRobot = RobotType.SOLDIER;
				}
				}else if(scheduleNum == 0){
					potentialRobot = RobotType.SCOUT;
				}else if(scheduleNum>0){
					potentialRobot = RobotType.LUMBERJACK;
				}
				if(rc.isBuildReady() && toProduce && id == 1) {
					dir = findOpenDirection(potentialRobot);
					if (dir != (null) && rc.canBuildRobot(potentialRobot, dir)) {
						rc.buildRobot(potentialRobot, dir);
						if (potentialRobot!=RobotType.SCOUT){
							rc.broadcast(BIO_NUM_CHANNEL, rc.readBroadcast(BIO_NUM_CHANNEL)+1);
						}
						rc.broadcast(GARDENER_SCHEDULE_CHANNEL, rc.readBroadcast(GARDENER_SCHEDULE_CHANNEL)+1);
					}
				}

				// Clock.yield() makes the robot wait until the next turn, then it will perform this loop again
				Clock.yield();

			} catch (Exception e) {
				System.out.println("Gardener Exception");
				e.printStackTrace();
			}
		}
	}

	static Direction findOpenDirection(RobotType potentialRobot) {
		boolean open = false;
		int degrees = 0;
		Direction openDir = new Direction(degrees);
		while(!open && degrees < 360) {
			openDir = openDir.rotateRightDegrees(5);
			degrees += 5;
			if(rc.canBuildRobot(potentialRobot, openDir)) {
				open = true;
			}
		}
		if (open) {
			return openDir;
		} else {
			return null;
		}
	}

	static void GardenersMove(int id) throws GameActionException{
		try{
			Direction treeDir = rc.getLocation().directionTo(rc.getInitialArchonLocations(rc.getTeam())[0]);
			boolean north = true;
			boolean south = true;
			boolean east = true;
			boolean west = true;
			if (!rc.canPlantTree(Direction.getNorth())){
				north = false;
			}
			if (!rc.canPlantTree(Direction.getEast())){
				east = false;
			}
			if (!rc.canPlantTree(Direction.getSouth())){
				south = false;
			}
			if (!rc.canPlantTree(Direction.getWest())){
				west = false;
			}
			if (!north || !east || !west || !south){
				if (!north){
					treeDir = Direction.getNorth();
				}
				if (!east){
					treeDir = Direction.getEast();
				}
				if (!west){
					treeDir = Direction.getWest();
				}
				if (!south){
					treeDir = Direction.getSouth();
				}
				for (int i = 0; i<72; i++){
					treeDir = treeDir.rotateLeftDegrees(5);
					if (rc.canPlantTree(treeDir)){
						break;
					}
				}
			}
			//tree gardener id 0
			/*if(id == 0){
				TreeInfo[] nearbyTrees = rc.senseNearbyTrees(2, rc.getTeam());
				if(nearbyTrees.length < 6){
							if(rc.canPlantTree(treeDir)){
								rc.plantTree(treeDir);
					}else{
					Direction dir = rc.getLocation().directionTo(nearbyTrees[0].location);
					for(int i = 60; i < 360; i+= 60){
						if(rc.canPlantTree(dir.rotateLeftDegrees(i))){
							rc.plantTree(dir.rotateLeftDegrees(i));
						}

					}
				}
				}
				if(nearbyTrees.length > 0){
					float[] remainingHealth = new float[nearbyTrees.length];
					for(int j = 0; j < nearbyTrees.length; j++){
						remainingHealth[j] = nearbyTrees[j].getHealth();
					}
					int lowestSpot = 0;
					for(int k = 1; k < remainingHealth.length; k++){
						if(remainingHealth[k] < remainingHealth[lowestSpot]){
							lowestSpot = k;
						}
					}
					if (rc.canMove(rc.getLocation().directionTo(nearbyTrees[lowestSpot].location))){
						rc.move(rc.getLocation().directionTo(nearbyTrees[lowestSpot].location));
					}
					if (nearbyTrees.length > lowestSpot){
					if(rc.canWater(nearbyTrees[lowestSpot].getLocation())){
						rc.water(nearbyTrees[lowestSpot].getLocation());
					}
					}
				}
			}else{*/
			TreeInfo[] nearbyTrees = rc.senseNearbyTrees(2, rc.getTeam());
			boolean skipped = false;
			if(nearbyTrees.length < 5){
				if(nearbyTrees.length==0){
					if(rc.canPlantTree(treeDir)){
						rc.plantTree(treeDir);
					}
				}else if (nearbyTrees.length == 5){
					skipped = false;
				}else{
					Direction dir = rc.getLocation().directionTo(nearbyTrees[0].location);
					for(int i = 60; i < 360; i+= 60){
						if(rc.canPlantTree(dir.rotateLeftDegrees(i))){
							if(rc.canPlantTree(dir.rotateLeftDegrees(i+60))){
								rc.plantTree(dir.rotateLeftDegrees(i));
							}else{
								skipped = true;
							}
							if (skipped && rc.senseNearbyTrees(2, rc.getTeam()).length == 4 && rc.canPlantTree(dir.rotateLeftDegrees(i))){
								rc.plantTree(dir.rotateLeftDegrees(i));
							}
						}

					}
				}
			}
			if(nearbyTrees.length > 0){
				float[] remainingHealth = new float[nearbyTrees.length];
				for(int j = 0; j < nearbyTrees.length; j++){
					remainingHealth[j] = nearbyTrees[j].getHealth();
				}
				int lowestSpot = 0;
				for(int k = 1; k < remainingHealth.length; k++){
					if(remainingHealth[k] < remainingHealth[lowestSpot]){
						lowestSpot = k;
					}
				}
				if (rc.canMove(rc.getLocation().directionTo(nearbyTrees[lowestSpot].location))){
					rc.move(rc.getLocation().directionTo(nearbyTrees[lowestSpot].location));
				}
				if (nearbyTrees.length > lowestSpot){
					if(rc.canWater(nearbyTrees[lowestSpot].getLocation())){
						rc.water(nearbyTrees[lowestSpot].getLocation());
					}
				}
			}
		}catch(Exception e){
			System.out.println(e);
			e.printStackTrace();
		}
	}


	static void runSoldier() throws GameActionException {
		System.out.println("I'm a soldier!");
		MapLocation targetLoc2 = rc.getInitialArchonLocations(opponentTeam)[0];
		Direction targetDir2 = rc.getLocation().directionTo(targetLoc2);
		int spawnRound = rc.getRoundNum();
		boolean pinged = false;
		boolean movingLeft = false;
		// The code you want your robot to perform every round should be in this loop
		while (true) {

			// Try/catch blocks stop unhandled exceptions, which cause your robot to explode
			try {
				MapLocation myLoc = rc.getLocation();
				RobotType myType =  rc.getType();
				// get target location and direction
				int xCoord = rc.readBroadcast(TARGET_X_COORD);
				int yCoord = rc.readBroadcast(TARGET_Y_COORD);
				MapLocation targetLoc = new MapLocation(xCoord, yCoord);
				if (!pinged && rc.getHealth()<10){
					rc.broadcast(BIO_NUM_CHANNEL, rc.readBroadcast(BIO_NUM_CHANNEL)-1);
					pinged = true;
				}
				RobotInfo[] initialRobots = rc.senseNearbyRobots(2, ourTeam);
				Direction oppDir = randomDirection();
				for(RobotInfo robot : initialRobots) {
					if(robot.type.equals(RobotType.GARDENER)) {
						oppDir = rc.getLocation().directionTo(robot.location).opposite();
					}
				}
				if(rc.getRoundNum() < spawnRound + 5) {
					tryMove(oppDir);
				}

				//sense enemy robots and trees
				Direction targetDir = null;
				RobotInfo[] enemies = rc.senseNearbyRobots(myType.sensorRadius, opponentTeam);
				TreeInfo[] trees = rc.senseNearbyTrees(myType.sensorRadius, opponentTeam);

				// broadcast enemy archons and gardeners
				if (rc.readBroadcast(TARGET_X_COORD) == 0) {
					reportEnemyArchonsAndGardeners(enemies);
				}
				
				// if target eliminated, broadcast : else, set targetDir
				if (xCoord != 0) {
					boolean eliminated = checkTarget(targetLoc, targetDir, enemies);
					if (eliminated) {
						rc.broadcast(TARGET_X_COORD, 0);
						rc.broadcast(TARGET_Y_COORD, 0);
					} else {
						targetDir = myLoc.directionTo(targetLoc);
					}
				}

				MapLocation nearbyTargetLoc = chooseTarget(enemies, trees);
				Direction nearbyTargetDir = null;

				// if no target, choose a nearby enemy
				if (nearbyTargetLoc != null) {
					nearbyTargetDir = myLoc.directionTo(nearbyTargetLoc);
				}

				// move towards enemy
				if (nearbyTargetLoc != null) {
					RobotInfo b = null;
					if (rc.canSenseLocation(nearbyTargetLoc)) {
						b = rc.senseRobotAtLocation(nearbyTargetLoc);
					}
					if(!rc.hasMoved() && b != null){
						MapLocation shifty = stayShifty(b);
						if(shifty != null){
							moveToLoc(shifty, movingLeft);
						}
					}
				}
				if (nearbyTargetDir != null) {
					if(!rc.hasMoved()) {
						moveToLoc(nearbyTargetLoc, movingLeft);
					}
				} else if (targetDir != null) {
					if(!rc.hasMoved()) {
						moveToLoc(targetLoc, movingLeft);
					}
				}

				// randomly move
				if (!rc.hasMoved()) {
					Direction randomDir = randomDirection();
					if(rc.canMove(randomDir)){
						tryMove(randomDir);
					}					
				}

				// if enemies, attack them
				if(nearbyTargetLoc != null){
					attack(nearbyTargetLoc);
				}

				// Clock.yield() makes the robot wait until the next turn, then it will perform this loop again
				Clock.yield();

			} catch (Exception e) {
				System.out.println("Soldier Exception");
				e.printStackTrace();
			}
		}
	}

	static boolean checkTarget(MapLocation targetLoc, Direction targetDir, RobotInfo[] enemies) throws GameActionException {
		boolean eliminated = false;
		if(rc.getLocation().isWithinDistance(targetLoc, 1)) {
			int pos = 0;
			boolean found = false;
			while (!found && pos < enemies.length) {
				RobotInfo robot = enemies[pos];
				RobotType type = robot.type;
				if (type.equals(RobotType.ARCHON) || type.equals(RobotType.GARDENER)) {
					found = true;
					rc.broadcast(TARGET_X_COORD, (int) robot.location.x);
					rc.broadcast(TARGET_Y_COORD, (int) robot.location.y);
				}
				pos++;
			}
			// set eliminated to if archon is not found
			eliminated = !found;
		}
		return eliminated;
	}

	static void shakeTrees(TreeInfo[] neutralTrees) throws GameActionException {
		MapLocation myLoc = rc.getLocation();
		if (neutralTrees.length > 0){
			ArrayList<TreeInfo> bulleted = new ArrayList<TreeInfo>();
			for (int i = 0; i<neutralTrees.length; i++){
				if (neutralTrees[i].containedBullets > 0){
					bulleted.add(neutralTrees[i]);
				}
			}
			if (bulleted.size() > 0){
				float dist = 10000;
				int closest = 0;
				for (int i = 0; i<bulleted.size(); i++){
					float d = bulleted.get(i).getLocation().distanceTo(myLoc);
					if (d<dist){
						dist = d;
						closest = i;
					}
				}
				Direction moveTo = myLoc.directionTo(bulleted.get(closest).getLocation());
				if(rc.canMove(moveTo) && !rc.hasMoved() && rc.getType() != RobotType.GARDENER){
					rc.move(moveTo);
				}
			}
			for (int i = 0; i<neutralTrees.length; i++){
				MapLocation loc = neutralTrees[i].location;
				if(rc.canShake(loc)){
					rc.shake(loc);
				}
			}
		}
	}

	static MapLocation chooseTarget(RobotInfo[] enemies, TreeInfo[] trees) throws GameActionException {
		MapLocation target = null;
		// choose robot target
		if(enemies.length > 0) {
			target = chooseRobotTarget(enemies);
		}
		// if no robot target, choose tree target
		if(target == null && trees.length > 0) {
			target = chooseTreeTarget(trees);
		}
		// return target location
		return target;
	}

	static void attack(MapLocation target) throws GameActionException {
		if(target != null) {
			Direction targetDir = rc.getLocation().directionTo(target);
			int shotType = chooseShotType(target);
			if(shotType == 1 && rc.canFireSingleShot()) {
				rc.fireSingleShot(targetDir);
			} else if (shotType == 3 && rc.canFireTriadShot()) {
				rc.fireTriadShot(targetDir);
			} else if(rc.canFirePentadShot()) {
				rc.firePentadShot(targetDir);
			}
		}
	}

	static MapLocation chooseTreeTarget(TreeInfo[] trees) throws GameActionException {
		float[] treePoints = new float[trees.length];
		MapLocation myLoc = rc.getLocation();
		float minPoint = 1000;
		MapLocation treeLoc = trees[0].location;
		for(int i = 0; i < trees.length; i++) {
			TreeInfo tree = trees[i];
			float distance = myLoc.distanceTo(tree.location);
			treePoints[i] = distance * distance / 10;
			treePoints[i] += tree.health / tree.maxHealth * 10;
			if (checkFriendlyFire(myLoc.directionTo(tree.location), distance)) {
				treePoints[i] += 1000;
			}
			if(treePoints[i] < minPoint) {
				minPoint = treePoints[i];
				treeLoc = tree.location;
			}
		}
		return treeLoc;
	}


	static float findObstacleBetweenTreeTarget(float distance, TreeInfo target) throws GameActionException {
		float points = 0;
		float minDistance = rc.getType().bodyRadius + 1;
		float maxDistance = distance - target.getRadius();
		MapLocation myLoc = rc.getLocation();
		Direction dir = myLoc.directionTo(target.location);
		boolean isObstacle = false;

		// loop through locations between yourself and target at intervals of 1
		while(!isObstacle && minDistance < maxDistance) {
			// get location between you and target
			MapLocation loc = myLoc.add(dir, minDistance);
			if(!rc.canSenseLocation(loc)) {
				break;
			}
			// find if robot or tree at location
			if(rc.isLocationOccupiedByRobot(loc)) {
				//obstacle found
				isObstacle = true;
				RobotInfo robot = rc.senseRobotAtLocation(loc);
				// if our team, don't attack; if opponent, then replace target with obstacle
				if(robot.team.equals(ourTeam)) {
					points += 1000;
				}
			} else if (rc.isLocationOccupiedByTree(loc)) {
				//obstacle found
				isObstacle = true;
				TreeInfo tree = rc.senseTreeAtLocation(loc);
				// if ourTeam, don't attack; if opponent, replace with 18; if neutral, don't attack
				Team treeTeam = tree.team;
				if(treeTeam.equals(ourTeam)) {
					points += 1000;
				} else if (treeTeam.equals(Team.NEUTRAL)) {
					points += 1000;
				}
			}
			minDistance++;
		}

		return points;
	}

	static boolean checkFriendlyFire(Direction d, float distance){
		RobotInfo[] friendlyBots = rc.senseNearbyRobots(distance, rc.getTeam());
		TreeInfo[] neutralTrees = rc.senseNearbyTrees(distance, Team.NEUTRAL);
		int i = 0;
		MapLocation myLoc = rc.getLocation();
		boolean friendlyFire = false;
		while (!friendlyFire && i < friendlyBots.length) {
			if(willPotentiallyCollideWithMapLoc(d, friendlyBots[i].getLocation(), myLoc)){
				friendlyFire = true;
			}
			i++;
		}
		if (!friendlyFire) {
			i = 0;
			while (!friendlyFire && i < neutralTrees.length) {
				if(willPotentiallyCollideWithMapLoc(d, neutralTrees[i].getLocation(), myLoc)){
					friendlyFire = true;
				}
				i++;
			}
		}
		return friendlyFire;
	}

	static float findObstacleBetweenTarget(float distance, RobotInfo target, Map<RobotType, Integer> RobotTypePoints) throws GameActionException {
		float points = 0;
		float minDistance = rc.getType().bodyRadius + 1;
		float maxDistance = distance - target.getRadius();
		MapLocation myLoc = rc.getLocation();
		Direction dir = myLoc.directionTo(target.location);
		boolean isObstacle = false;

		// loop through locations between yourself and target at intervals of 1
		while(!isObstacle && minDistance < maxDistance) {
			// get location between you and target
			MapLocation loc = myLoc.add(dir, minDistance);
			if(!rc.canSenseLocation(loc) || minDistance < maxDistance) {
				break;
			}
			// find if robot or tree at location
			if(rc.isLocationOccupiedByRobot(loc)) {
				//obstacle found
				isObstacle = true;
				RobotInfo robot = rc.senseRobotAtLocation(loc);
				// if our team, don't attack; if opponent, then replace target with obstacle
				if(robot.team.equals(ourTeam)) {
					points += 1000;
				} else {
					points += RobotTypePoints.get(robot.type) * 3 - RobotTypePoints.get(target.type);
				}
			} else if (rc.isLocationOccupiedByTree(loc)) {
				//obstacle found
				isObstacle = true;
				TreeInfo tree = rc.senseTreeAtLocation(loc);
				// if ourTeam, don't attack; if opponent, replace with 18; if neutral, don't attack
				if(tree.team.equals(ourTeam)) {
					points += 1000;
				} else if (tree.team.equals(opponentTeam)) {
					points += 18 - RobotTypePoints.get(target.type);
				} else {
					points += 1000;
				}
			}
			minDistance++;
		}

		return points;
	}

	static MapLocation chooseRobotTarget(RobotInfo[] enemies) throws GameActionException {
		Map<RobotType, Integer> RobotTypePoints = new HashMap<RobotType, Integer>();
		RobotTypePoints.put(RobotType.TANK, 0);
		RobotTypePoints.put(RobotType.LUMBERJACK, 1);
		RobotTypePoints.put(RobotType.SOLDIER, 2);
		RobotTypePoints.put(RobotType.GARDENER, 3);
		RobotTypePoints.put(RobotType.SCOUT, 4);
		RobotTypePoints.put(RobotType.ARCHON, 5);
		float[] robotPoints = new float[enemies.length];
		MapLocation myLoc = rc.getLocation();
		for(int i = 0; i < enemies.length; i++) {
			MapLocation enemyLoc = enemies[i].getLocation();
			RobotType enemyType = enemies[i].getType();
			//Adds 4 things together:
			//1: gets the distance to the other robot, squares it
			float distance = myLoc.distanceTo(enemyLoc);
			robotPoints[i] = distance * distance /10;
			//2: gets the percent health (as a decimal) that the other robot is at and multiplies that decimal by 10
			robotPoints[i] += (float)(enemies[i].getHealth()/enemyType.maxHealth)*10;
			//3: gets the map value for the type of robot
			robotPoints[i] += RobotTypePoints.get(enemyType)*3;
			//4: finds if there is something in between you and the target
			if(checkFriendlyFire(myLoc.directionTo(enemyLoc), distance)){
				robotPoints[i] += 1000;
			}

		}
		int counter = 0;
		for(int i = 1; i < robotPoints.length; i++){
			if(robotPoints[counter] < robotPoints[i]){
				counter = i;
			}
		}

		if(robotPoints[counter] > 999) {
			return null;
		} else {
			return enemies[counter].location;
		}
	}

	static int chooseShotType(MapLocation target) {
		int shots = 1;
		if (rc.canSenseLocation(target)){
			int robotsNearTarget = rc.senseNearbyRobots(target, 5, opponentTeam).length;
			int treesNearTarget = rc.senseNearbyTrees(target, 5, opponentTeam).length;
			if(robotsNearTarget + treesNearTarget >= 2) {
				float distance = rc.getLocation().distanceTo(target);
				Direction dir = rc.getLocation().directionTo(target);
				if(robotsNearTarget + treesNearTarget >= 3) {
					boolean friendlyFire = false;
					Direction offThirty = dir.rotateLeftDegrees(30);
					Direction offFifteen = dir.rotateLeftDegrees(15);
					Direction onFifteen = dir.rotateRightDegrees(15);
					Direction onThirty = dir.rotateRightDegrees(30);
					if (checkFriendlyFire(offThirty, distance)) {
						friendlyFire = true;
					}
					if (!friendlyFire && checkFriendlyFire(offFifteen, distance)) {
						friendlyFire = true;
					}
					if (!friendlyFire && checkFriendlyFire(offThirty, distance)) {
						friendlyFire = true;
					}
					if (!friendlyFire && checkFriendlyFire(onFifteen, distance)) {
						friendlyFire = true;
					}
					if (!friendlyFire && checkFriendlyFire(onThirty, distance)) {
						friendlyFire = true;
					}
					if (!friendlyFire) {
						shots = 5;
					}
				}
				if (shots == 1) {
					boolean friendlyFire = false;
					Direction offTwenty = dir.rotateLeftDegrees(20);
					Direction onTwenty = dir.rotateRightDegrees(20);
					if (checkFriendlyFire(offTwenty, distance)) {
						friendlyFire = true;
					}
					if (!friendlyFire && checkFriendlyFire(onTwenty, distance)) {
						friendlyFire = true;
					}
					if (!friendlyFire) {
						shots = 3;
					}
				}
			}
		}
		return shots;
	}

	static void runLumberjack() throws GameActionException {
		int spawnRound = rc.getRoundNum();
		boolean pinged = false;
		boolean movingLeft = false;
		// The code you want your robot to perform every round should be in this loop
		while (true) {
			// Try/catch blocks stop unhandled exceptions, which cause your robot to explode
			try {
				// get target location and direction
				int xCoord = rc.readBroadcast(TARGET_X_COORD);
				int yCoord = rc.readBroadcast(TARGET_Y_COORD);
				MapLocation targetLoc = new MapLocation(xCoord, yCoord);
				//sense enemy robots and trees
				Direction targetDir = null;
				RobotInfo[] enemies = rc.senseNearbyRobots(rc.getType().sensorRadius, opponentTeam);
				TreeInfo[] enemyTrees = rc.senseNearbyTrees(rc.getType().sensorRadius, opponentTeam);
				TreeInfo[] neutralTrees = rc.senseNearbyTrees(rc.getType().sensorRadius, Team.NEUTRAL);
				if (!pinged &&rc.getHealth()<10){
					rc.broadcast(BIO_NUM_CHANNEL, rc.readBroadcast(BIO_NUM_CHANNEL)-1);
					pinged = true;
				}
				RobotInfo[] initialRobots = rc.senseNearbyRobots(2, ourTeam);
				Direction oppDir = randomDirection();
				for(RobotInfo robot : initialRobots) {
					if(robot.type.equals(RobotType.GARDENER)) {
						oppDir = rc.getLocation().directionTo(robot.location).opposite();
					}
				}
				if(rc.getRoundNum() < spawnRound + 5) {
					tryMove(oppDir);
				}
				
				// broadcast enemy archons and gardeners
				if (rc.readBroadcast(TARGET_X_COORD) == 0) {
					reportEnemyArchonsAndGardeners(enemies);
				}

				// if target eliminated, broadcast : else, set targetDir
				if (xCoord != 0) {
					boolean eliminated = checkTarget(targetLoc, targetDir, enemies);
					if (eliminated) {
						rc.broadcast(TARGET_X_COORD, 0);
						rc.broadcast(TARGET_Y_COORD, 0);
					} else {
						targetDir = rc.getLocation().directionTo(targetLoc);
					}
				}
				MapLocation nearbyTargetLoc = chooseTarget(enemies, enemyTrees);
				Direction nearbyTargetDir = null;
				// if no target, choose a nearby enemy
				if (nearbyTargetLoc != null) {
					nearbyTargetDir = rc.getLocation().directionTo(nearbyTargetLoc);
				}
				// move towards enemy
				if (nearbyTargetDir != null) {
					if(!rc.hasMoved()) {
						moveToLoc(nearbyTargetLoc, movingLeft);
					}
				} else if (targetDir != null) {
					if(!rc.hasMoved()) {
						moveToLoc(targetLoc,movingLeft);
					}
				}
				if(rc.senseNearbyRobots().length > 0){
					RobotInfo[] nearbyBots = rc.senseNearbyRobots();
					MapLocation location = rc.getLocation();
					int numOfEnemies = 0;
					int numOfFriends = 0;
					for(int i = 0; i < nearbyBots.length; i++){
						if(nearbyBots[i].getTeam().equals(rc.getTeam()) && location.isWithinDistance(nearbyBots[i].getLocation(), 2)){
							numOfFriends++;
						}
						else if(nearbyBots[i].getTeam().equals(rc.getTeam().opponent()) && location.isWithinDistance(nearbyBots[i].getLocation(), 2)){
							numOfEnemies++;
						}
					}
					//ratio of friends to enemies 
					if(((double)numOfFriends)/numOfEnemies < 1){
						rc.strike();
					}
				}
				if (neutralTrees.length > 0) {
					TreeInfo closestTree = neutralTrees[0];
					float distance = closestTree.location.distanceTo(rc.getLocation());
					for(int i = 1; i < neutralTrees.length; i++) {
						float neutralDistance = neutralTrees[i].location.distanceTo(rc.getLocation());
						if(neutralDistance < distance) {
							distance = neutralDistance;
							closestTree = neutralTrees[i];
						}
					}
					if(rc.canShake(closestTree.location)){
						rc.shake(closestTree.location);
					}
					if(rc.canChop(closestTree.location)) {
						rc.chop(closestTree.location);
					} else if(!rc.hasMoved() && rc.canMove(rc.getLocation().directionTo(closestTree.location))){
						rc.move(rc.getLocation().directionTo(closestTree.location));
					}
				}
				if(!rc.hasMoved()) {
					tryMove(randomDirection());
				}
				// Clock.yield() makes the robot wait until the next turn, then it will perform this loop again
				Clock.yield();
			} catch (Exception e) {
				System.out.println("Lumberjack Exception");
				e.printStackTrace();
			}
		}
	}

	static void runTank() throws GameActionException {
		//choose location here so it doesnt change every round
		MapLocation myLocation = rc.getLocation();
		MapLocation[] initialArchons = rc.getInitialArchonLocations(opponentTeam);
		Direction attack = myLocation.directionTo(initialArchons[(int)Math.random()*initialArchons.length]);
		boolean movingLeft = false;
		// The code you want your robot to perform every round should be in this loop
		while (true) {
			try{
				// get target location and direction
				int xCoord = rc.readBroadcast(TARGET_X_COORD);
				int yCoord = rc.readBroadcast(TARGET_Y_COORD);
				MapLocation targetLoc = new MapLocation(xCoord, yCoord);

				//sense enemy robots and trees
				Direction targetDir = null;
				RobotInfo[] enemies = rc.senseNearbyRobots(rc.getType().sensorRadius, opponentTeam);
				TreeInfo[] trees = rc.senseNearbyTrees(rc.getType().sensorRadius, opponentTeam);

				// if target eliminated, broadcast : else, set targetDir
				if (xCoord != 0) {
					boolean eliminated = checkTarget(targetLoc, targetDir, enemies);
					if (eliminated) {
						rc.broadcast(TARGET_X_COORD, 0);
						rc.broadcast(TARGET_Y_COORD, 0);
					} else {
						targetDir = rc.getLocation().directionTo(targetLoc);
					}
				}

				MapLocation nearbyTargetLoc = chooseTarget(enemies, trees);
				Direction nearbyTargetDir = null;

				// if no target, choose a nearby enemy
				if (nearbyTargetLoc != null) {
					nearbyTargetDir = rc.getLocation().directionTo(nearbyTargetLoc);
				}

				// move towards enemy
				if (nearbyTargetDir != null) {
					if(!rc.hasMoved()) {
						moveToLoc(nearbyTargetLoc, movingLeft);
					}
				} else if (targetDir != null) {
					if(!rc.hasMoved()) {
						moveToLoc(targetLoc, movingLeft);
					}
				}

				//attack closest enemy tree
				if(trees.length > 0){
					TreeInfo closestTree = trees[0];
					for(int i = 1; i < trees.length; i++){
						if (myLocation.distanceTo(trees[i].getLocation()) < myLocation.distanceTo(closestTree.getLocation())){
							closestTree = trees[i];
						}
						//if there are two trees the same distance attack the one with lower health
						if (myLocation.distanceTo(trees[i].getLocation()) == myLocation.distanceTo(closestTree.getLocation())){
							if(trees[i].getHealth() < closestTree.getHealth()){
								closestTree = trees[i];
							}
						}
					}

					Direction dirTree = rc.getLocation().directionTo(closestTree.location);
					if (!rc.hasMoved() && rc.canMove(dirTree)){
						rc.move(dirTree);
					}
				}

				if (!rc.hasMoved()) {
					Direction randomDir = randomDirection();
					if(rc.canMove(randomDir)){
						tryMove(randomDir);
					}					
				}

				// if enemies, attack them
				if(nearbyTargetLoc != null){
					attack(nearbyTargetLoc);
				}

				// Clock.yield() makes the robot wait until the next turn, then it will perform this loop again
				Clock.yield();

			} catch(Exception e){
				System.out.println("Tank Exception");
				e.printStackTrace();
			}
		}
	}	

	static void runScout() throws GameActionException {

		RobotInfo[] initialRobots = rc.senseNearbyRobots(2, ourTeam);
		Direction bounceDirection = randomDirection();
		for(int i = 0; i < initialRobots.length; i++) {
			RobotInfo robot = initialRobots[i];
			if(robot.type.equals(RobotType.GARDENER)) {
				bounceDirection = robot.location.directionTo(rc.getLocation());
			}
		}
		boolean movingLeft = false;

		// The code you want your robot to perform every round should be in this loop
		while (true) {
			try{
				TreeInfo[] neutralTrees = rc.senseNearbyTrees(rc.getType().sensorRadius, Team.NEUTRAL);
				if (neutralTrees.length > 0) {
					shakeTrees(neutralTrees);
				}


				//sense enemy robots and trees
				RobotInfo[] enemies = rc.senseNearbyRobots(RobotType.SOLDIER.sensorRadius, opponentTeam);
				MapLocation targetLoc = null;
				if(enemies.length > 0){
					//Direction targetDir = attack(enemies, trees);
					if (rc.readBroadcast(TARGET_X_COORD) == 0) {
						reportEnemyArchonsAndGardeners(enemies);
					}
					targetLoc = chooseRobotTarget(enemies);
				}

				// move towards enemy
				if (enemies.length > 0 && targetLoc != null) {
					RobotInfo b = null;
					if (rc.canSenseLocation(targetLoc)) {
						b = rc.senseRobotAtLocation(targetLoc);
					}
					if(!rc.hasMoved() && b != null){
						MapLocation shifty = stayShifty(b);
						if(shifty != null){
							moveToLoc(shifty, movingLeft);
						}
					}
				}
				if (!rc.hasMoved()) {
					bounceDirection = bounce(bounceDirection);
				}

				if (targetLoc != null) {
					attack(targetLoc);
				}

				// Clock.yield() makes the robot wait until the next turn, then it will perform this loop again
				Clock.yield();
			}catch(Exception e){
				System.out.println("Scout Exception");
				e.printStackTrace();
			}
		}

	}

	static void reportEnemyArchonsAndGardeners(RobotInfo[] enemies) throws GameActionException {
		int i = 0;
		boolean found = false;
		while (!found && i < enemies.length) {
			RobotInfo robot = enemies[i];
			if (robot.type.equals(RobotType.ARCHON)) {
				found = true;
				rc.broadcast(TARGET_X_COORD, Math.round(robot.location.x));
				rc.broadcast(TARGET_Y_COORD, Math.round(robot.location.y));
			}
			i++;
		}
		if (!found) {
			i = 0;
			while (!found && i < enemies.length) {
				RobotInfo robot = enemies[i];
				if (robot.type.equals(RobotType.GARDENER)) {
					found = true;
					rc.broadcast(TARGET_X_COORD, Math.round(robot.location.x));
					rc.broadcast(TARGET_Y_COORD, Math.round(robot.location.y));
				}
				i++;
			}
		}
	}

	static Direction bounce(Direction bounceDirection) throws GameActionException {
		MapLocation moveLocation = rc.getLocation().add(bounceDirection);
		if(rc.canMove(moveLocation) && rc.onTheMap(moveLocation)) {
			rc.move(moveLocation);
		} else {
			Direction alternateBounce = bounceDirection.rotateRightDegrees(90);
			if (rc.canMove(alternateBounce)) {
				bounceDirection = alternateBounce;
				rc.move(bounceDirection);
			} else {
				alternateBounce = bounceDirection.rotateLeftDegrees(90);
				if (rc.canMove(alternateBounce)) {
					bounceDirection = alternateBounce;
					rc.move(bounceDirection);
				}
			}
		}
		return bounceDirection;
	}

	static boolean willCollideWithMapLoc(BulletInfo bullet, MapLocation loc) {

		MapLocation myLocation = loc;
		// Get relevant bullet information
		Direction propagationDirection = bullet.dir;
		MapLocation bulletLocation = bullet.location;

		// Calculate bullet relations to this robot
		Direction directionToRobot = bulletLocation.directionTo(myLocation);
		float distToRobot = bulletLocation.distanceTo(myLocation);
		float theta = propagationDirection.radiansBetween(directionToRobot);

		// If theta > 90 degrees, then the bullet is traveling away from us and we can break early
		if (Math.abs(theta) > Math.PI/2) {
			return false;
		}



		// distToRobot is our hypotenuse, theta is our angle, and we want to know this length of the opposite leg.
		// This is the distance of a line that goes from myLocation and intersects perpendicularly with propagationDirection.
		// This corresponds to the smallest radius circle centered at our location that would intersect with the
		// line that is the path of the bullet.
		float perpendicularDist = (float)Math.abs(distToRobot * Math.sin(theta)); // soh cah toa :)

		return (perpendicularDist <= rc.getType().bodyRadius);
	}

	static boolean willPotentiallyCollideWithMapLoc(Direction dir, MapLocation otherLoc, MapLocation myLoc) {

		MapLocation myLocation = otherLoc;
		// Get relevant bullet information
		Direction propagationDirection = dir;
		MapLocation bulletLocation = myLoc;

		// Calculate bullet relations to this robot
		Direction directionToRobot = bulletLocation.directionTo(myLocation);
		float distToRobot = bulletLocation.distanceTo(myLocation);
		float theta = propagationDirection.radiansBetween(directionToRobot);

		// If theta > 90 degrees, then the bullet is traveling away from us and we can break early
		if (Math.abs(theta) > Math.PI/2) {
			return false;
		}



		// distToRobot is our hypotenuse, theta is our angle, and we want to know this length of the opposite leg.
		// This is the distance of a line that goes from myLocation and intersects perpendicularly with propagationDirection.
		// This corresponds to the smallest radius circle centered at our location that would intersect with the
		// line that is the path of the bullet.
		float perpendicularDist = (float)Math.abs(distToRobot * Math.sin(theta)); // soh cah toa :)

		return (perpendicularDist <= rc.getType().bodyRadius);
	}

	static Direction moveDirection(Direction movement){
		// Direction is movement that RC fired bullet
		// If rc didn't fire a bullet, put the direction as the direction 180 away from the archon
		BulletInfo[] bullets = rc.senseNearbyBullets();
		if(bullets.length > 0){
			boolean[] bulletsHit = new boolean[bullets.length];
			boolean danger = false;
			int counter = 0;
			while(!danger && counter<bulletsHit.length){
				if(willCollideWithMe(bullets[counter])){
					danger = true;
				}
				counter++; 
			}

			if(danger){
				float rad = rc.getType().strideRadius;
				ArrayList<Tuple<Direction, Integer>> bulletsPerDir = new ArrayList<Tuple<Direction, Integer>>();
				int multiplier = 1;
				for(int i = 0; i < 180; i+= 30){
					for(int l = 0; l < 2; l++){
						if(l == 0){
							l = 1;
						}
						else{
							l = -1;
						}
						MapLocation newLoc = rc.getLocation().add(movement.opposite().rotateLeftDegrees(i * l), rad);
						for(int j = 0; j < bullets.length; j++){
							int bulletCounter = 0;
							for(int k = 0; k < bullets.length; k++){
								if(willCollideWithMapLoc(bullets[k], newLoc)){
									bulletCounter++;
								}
							}
							if(bulletCounter == 0){
								return rc.getLocation().directionTo(newLoc);
							}
							else{
								bulletsPerDir.add(new Tuple<Direction, Integer>(rc.getLocation().directionTo(newLoc), bulletCounter));
							}
						}
					}
				}
				int pos = 0;
				int minBullets = bulletsPerDir.get(0).second;
				//find position of the lowest bullets in direction
				for(int i = 1; i < bulletsPerDir.size(); i++) {
					int bulletsInDir = bulletsPerDir.get(i).second;
					if(bulletsInDir < minBullets) {
						minBullets = bulletsInDir;
						pos = i;
					}
				}
				return bulletsPerDir.get(pos).first;
			}
			else{
				return null;
			}
		}
		return null;
	}

	/**
	 * Returns a random Direction
	 * @return a random Direction
	 */
	static Direction randomDirection() {
		return new Direction((float)Math.random() * 2 * (float)Math.PI);
	}

	/**
	 * Attempts to move in a given direction, while avoiding small obstacles directly in the path.
	 *
	 * @param dir The intended direction of movement
	 * @return true if a move was performed
	 * @throws GameActionException
	 */
	static boolean tryMove(Direction dir) throws GameActionException {
		return tryMove(dir,20,3);
	}

	/**
	 * Attempts to move in a given direction, while avoiding small obstacles direction in the path.
	 *
	 * @param dir The intended direction of movement
	 * @param degreeOffset Spacing between checked directions (degrees)
	 * @param checksPerSide Number of extra directions checked on each side, if intended direction was unavailable
	 * @return true if a move was performed
	 * @throws GameActionException
	 */
	static boolean tryMove(Direction dir, float degreeOffset, int checksPerSide) throws GameActionException {

		// First, try intended direction
		if (rc.canMove(dir) && !rc.hasMoved()) {
			rc.move(dir);
			return true;
		}

		// Now try a bunch of similar angles
		boolean moved = false;
		int currentCheck = 1;

		while(currentCheck<=checksPerSide) {
			// Try the offset of the left side
			if(rc.canMove(dir.rotateLeftDegrees(degreeOffset*currentCheck)) && !rc.hasMoved()) {
				rc.move(dir.rotateLeftDegrees(degreeOffset*currentCheck));
				return true;
			}
			// Try the offset on the right side
			if(rc.canMove(dir.rotateRightDegrees(degreeOffset*currentCheck)) && !rc.hasMoved()) {
				rc.move(dir.rotateRightDegrees(degreeOffset*currentCheck));
				return true;
			}
			// No move performed, try slightly further
			currentCheck++;
		}

		// A move never happened, so return false.
		return false;
	}

	/**
	 * A slightly more complicated example function, this returns true if the given bullet is on a collision
	 * course with the current robot. Doesn't take into account objects between the bullet and this robot.
	 *
	 * @param bullet The bullet in question
	 * @return True if the line of the bullet's path intersects with this robot's current position.
	 */
	static boolean moveAroundObstacles(Direction dir, boolean movingLeft) throws GameActionException{
		if (!rc.hasMoved()){
			int i = 0;
			if (movingLeft){
				i = 0;
				while (i<270){
					i+=5;
					if (rc.canMove(dir.rotateLeftDegrees(i)) && !rc.hasMoved()){
						rc.move(dir.rotateLeftDegrees(i));
						return true;
					}
				}
				i = 0;
				while (i<270){
					i+=5;
					if (rc.canMove(dir.rotateLeftDegrees(-i)) && !rc.hasMoved()){
						rc.move(dir.rotateLeftDegrees(-i));
						return false;
					}
				}
			}else{
				i = 0;
				while (i<270){
					i+=5;
					if (rc.canMove(dir.rotateLeftDegrees(-i)) && !rc.hasMoved()){
						rc.move(dir.rotateLeftDegrees(-i));
						return false;
					}
				}
				i = 0;
				while (i<270){
					i+=5;
					if (rc.canMove(dir.rotateLeftDegrees(i)) && !rc.hasMoved()){
						rc.move(dir.rotateLeftDegrees(i));
						return true;
					}
				}
			}
		}
		return movingLeft;
	}

	static void moveToLoc(MapLocation loc, boolean movingLeft) throws GameActionException{

		Direction dir = rc.getLocation().directionTo(loc);
		if (rc.canMove(dir)){
			rc.move(dir);
		}else{
			dir = rc.getLocation().directionTo(loc);
			movingLeft = moveAroundObstacles(dir, movingLeft);
		}
	}

	static boolean willCollideWithMe(BulletInfo bullet) {
		MapLocation myLocation = rc.getLocation();

		// Get relevant bullet information
		Direction propagationDirection = bullet.dir;
		MapLocation bulletLocation = bullet.location;

		// Calculate bullet relations to this robot
		Direction directionToRobot = bulletLocation.directionTo(myLocation);
		float distToRobot = bulletLocation.distanceTo(myLocation);
		float theta = propagationDirection.radiansBetween(directionToRobot);

		// If theta > 90 degrees, then the bullet is traveling away from us and we can break early
		if (Math.abs(theta) > Math.PI/2) {
			return false;
		}

		// distToRobot is our hypotenuse, theta is our angle, and we want to know this length of the opposite leg.
		// This is the distance of a line that goes from myLocation and intersects perpendicularly with propagationDirection.
		// This corresponds to the smallest radius circle centered at our location that would intersect with the
		// line that is the path of the bullet.
		float perpendicularDist = (float)Math.abs(distToRobot * Math.sin(theta)); // soh cah toa :)

		return (perpendicularDist <= rc.getType().bodyRadius);
	}

	static MapLocation stayShifty(RobotInfo targetedEnemy) throws GameActionException{
		MapLocation myLoc = rc.getLocation();

		MapLocation enemyLoc = targetedEnemy.getLocation();
		RobotType myRobotType = rc.getType();
		RobotType myEnemyType = targetedEnemy.getType();
		float myStrideRadius = myRobotType.strideRadius;
		if(myRobotType.sensorRadius <= myEnemyType.sensorRadius){
			return null;
		} else if (myEnemyType.equals(RobotType.ARCHON) || myEnemyType.equals(RobotType.GARDENER)) {
			return null;
		} else {
			Direction potentialDirection = myLoc.directionTo(enemyLoc);
			MapLocation potentialLocation = myLoc.add(potentialDirection, myStrideRadius);
			if(myLoc.distanceTo(enemyLoc) < myEnemyType.sensorRadius && rc.canMove(potentialLocation)){
				return myLoc.add(potentialDirection.opposite(), myStrideRadius);
			}else{
				if(rc.canMove(potentialLocation)){
					return potentialLocation;
				}
				else{
					for(int i = 15; i <=90; i =15){
						Direction left = potentialDirection.rotateLeftDegrees(i);
						if(rc.canMove(left)){
							return myLoc.add(left, myStrideRadius);
						}
						left = potentialDirection.rotateRightDegrees(i);
						if(rc.canMove(left)){
							return myLoc.add(left, myStrideRadius);
						}
					}
					return null;
				}
			}
		}
	}
}

/**
 * Tuple
 * 
 * a simple tuple class so that tuples can be used.
 */
class Tuple<X, Y> { 
	public X first; 
	public Y second; 
	public Tuple(X first, Y second) { 
		this.first = first; 
		this.second = second; 
	} 
}
